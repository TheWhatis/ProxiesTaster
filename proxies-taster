#!/usr/bin/env python3

# Standarts
import os
import sys

# Asyncio
import asyncio

# args
import argparse

# Colorama
from colorama import init

# Tqdm
from tqdm import tqdm

# ProxiesTaster
from proxies_taster import Protocol
from proxies_taster import WorkedProxy
from proxies_taster import ProxiesTaster
from proxies_taster.events_data import Events

# My logger
from proxies_parser_logger import setting_logging


def country_filter(countries: list[str]):
    """
    Фильтр по стране для прокси

    :param countries: Список доступных стран (по-умолчанию все)
    :type countries: list[str] - default: []

    :return: Возвращает функцию,
        которая будет фильтровать
    :rtype: Callable[WorkedProxy, bool]
    """
    def filt(proxy: WorkedProxy):
        if not countries:
            return True

        if not proxy.country:
            return False

        return proxy.country in countries

    return filt


def status_codes_filter(codes: list[int]):
    """
    Фильтр по кодам ответов HTTP

    :param codes: Список допустимых кодов
    :type codes: list[int]

    :return: Функция-фильтр
    :rtype: Callable[WorkedProxy, bool]
    """
    def filt(proxy: WorkedProxy):
        return True if not codes else proxy.status in codes

    return filt


def string_cast(proxy: WorkedProxy) -> str:
    """
    Преобразовывает рабочий прокси
    в строку

    :param proxy: Рабочий прокси
    :type proxy: WorkedProxy

    :return: Преобразованный в
        строку прокси
    :rtype: str
    """
    return f"{proxy.status} {proxy.url} {proxy.country}"


def parse_proxies(proxies: str) -> list[str]:
    """
    Парсим список прокси

    :param proxies: Получаем прокси, разделенные
        переводом строки или пробелом
    :type proxies: str

    :return: Возвращает распаршенный
        список прокси
    :rtype: list[str]

    **Пример работы**

    .. code-block:: python

        proxies = parse_proxies('72.195.34.59:4145 43.248.27.8:4646')
    """
    proxies = proxies.strip().split("\n")
    return list(
        set(
            sum(
                [proxy.split(
                    ',' if ',' in proxy else ' '
                ) for proxy in proxies], []
            )
        )
    )


def check_end(tbar) -> callable:
    """
    Обработчик для окончания проверки
    одного отдельного прокси - Events.check_end

    :param tbar: Иницилизированный tqdm

    :param returns: Возвращает функцию wrapper
    :rtype: callable
    """
    def wrapper(event):
        tbar.update(1)

    return wrapper


async def main():
    """
    Основная функция;

    Запускается, если
    программа была запущена
    через терминал (а не как модуль)
    """
    # Иницилизация colorama
    init()

    # Основные аргументы
    # Парсим входные аргументы
    parser = argparse.ArgumentParser(
        description="Скрипт, позволяющий проверить все переданные прокси"
    )


    # Название файла, откуда получаем прокси
    parser.add_argument(
        "proxies",
        type=str,
        help="Путь до файла со списком прокси, либо просто список прокси (разделенные переводом строки или пробелом)",
        nargs='?'
    )

    # Куда сохранять рабочие и
    # сортированные прокси
    parser.add_argument(
        "--out",
        "-o",
        type=str,
        help="Путь до файла, в который необходимо записать результат"
    )

    # Куда добавлять рабочие и
    # сортированные прокси
    parser.add_argument(
        "--append",
        "-a",
        type=str,
        help="Добавить полученный результат в конец переданного файла"
    )

    # Количество асинхронных запросов
    parser.add_argument(
        "--workers",
        "-w",
        type=int,
        help="Количество \"воркеров\" - асинхронных запросов",
        default=200
    )

    # По каким протоколам фильтровать
    parser.add_argument(
        "--protocols",
        "-p",
        nargs='+',
        type=str,
        help="Фильтр по протоколам прокси (socks4, socks5 и т.д.)",
        default=[protocol.value for protocol in Protocol]
    )

    # По какой стране фильтровать
    parser.add_argument(
        "--countries",
        "-c",
        nargs='+',
        type=str,
        help="Фильтр по странам (необходимо вводить локаль: RU, EN, US и т.д.)",
        default=[]
    )

    # По каким кодам ответов
    # HTTP фильтровать
    parser.add_argument(
        "--status-codes",
        '-sc',
        nargs='+',
        type=int,
        help="Фильтр по HTTP кодам ответов от прокси (по-умолчанию все)",
        default=[]
    )

    # Файл с конфигом
    parser.add_argument(
        "--logconfig",
        "-lc",
        type=str,
        help="Путь до конфига для вывода логов",
        default="log.config.json"
    )

    # Директория куда сохранять логи
    parser.add_argument(
        "--logdir",
        "-ld",
        type=str,
        help="В какую директорию сохранять файлы логов"
    )

    # Уровень логироания
    parser.add_argument(
        "--loglevel",
        "-ll",
        type=str,
        help="Уровень вывода логов (debug, critical, info и т.д.) только для вывода в терминал (stdout)"
    )

    # Формат логов
    parser.add_argument(
        "--logformat",
        "-lf",
        type=str,
        help="log format"
    )

    # Выводить ли расширенную
    # информацию
    parser.add_argument(
        '--verbose',
        '-v',
        help='Расширенный вывод информации о работе скрипта',
        action='store_true',
        default=False
    )

    # Получаем аргументы
    args = parser.parse_args()

    # Получаем возможный ввод из pipeline
    args.proxies = args.proxies if sys.stdin.isatty() \
        else ' '.join(sys.stdin.read().splitlines()).strip()

    if not args.proxies:
        parser.error("Argument 'proxies' is positional argument")

    # Получаем прокси из файла (если файл)
    if os.path.exists(args.proxies):
        with open(args.proxies, "r", encoding="UTF-8") as proxies_file:
            proxies = parse_proxies(proxies_file.read())
    else:
        proxies = parse_proxies(args.proxies)

    # Define log config
    logkwargs = {}
    if args.logdir:
        logkwargs["dir"] = args.logdir

    if args.loglevel:
        logkwargs["level"] = args.loglevel

    if args.logformat:
        logkwargs["format"] = args.logformat

    FLOGGER, DLOGGER = setting_logging(args.logconfig, **logkwargs)

    # Объект проверяльщика прокси
    taster = ProxiesTaster(proxies)

    # Его настройки
    taster.set_workers(args.workers)
    taster.set_protocols(
        [
            Protocol(protocol)
            for protocol in args.protocols
        ]
    )

    # Установка обработчиков
    taster.on(
        Events.error, lambda event: event.message
        and DLOGGER.error(event.message)
    )
    taster.on(
        Events.check_error, lambda event: event.level == 'not work'
        and DLOGGER.info(f"Proxy dont work {event.proxy}"),
    )
    taster.on(
        Events.check_success, lambda event: [
            DLOGGER.info(f"Proxy work {event.proxy.proxy}"),
            DLOGGER.debug(f"Work proxy data {event.proxy}"),
        ]
    )

    tbar = tqdm(total=len(proxies), dynamic_ncols=True)
    taster.on(
        Events.check_end, check_end(tbar)
    )

    # Получаем прокси, фильтруем их
    # и преобразуем в строки
    results = list(
        map(
            string_cast, filter(
                status_codes_filter(args.status_codes), filter(
                    country_filter(args.countries),
                    await taster.run()
                )
            )
        )
    )

    # Сохраняем в файл
    if args.out:
        if args.verbose:
            DLOGGER.info(f"Write result in '{args.out}'")
        with open(args.out, "w", encoding="uTF-8") as valid_proxy:
            valid_proxy.write("\n".join(results))

    # Добавляем в файл
    if args.append:
        if args.verbose:
            DLOGGER.info(
                f"Append to file end result; Filename is '{args.append}'"
            )

        with open(args.append, "a", encoding="UTF-8") as valid_proxy:
            for proxy in results:
                valid_proxy.write("\n" + proxy)

    for proxy in results:
        tqdm.write(proxy)

    tbar.close()


if __name__ == "__main__":
    asyncio.run(main())
